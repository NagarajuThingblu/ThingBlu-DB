{"remainingRequest":"D:\\SVNProjects\\thingbluangular5svnv1\\thingblusvn\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!D:\\SVNProjects\\thingbluangular5svnv1\\thingblusvn\\node_modules\\zone.js\\dist\\long-stack-trace-zone.js","dependencies":[{"path":"D:\\SVNProjects\\thingbluangular5svnv1\\thingblusvn\\node_modules\\zone.js\\dist\\long-stack-trace-zone.js","mtime":1523166820000},{"path":"D:\\SVNProjects\\thingbluangular5svnv1\\thingblusvn\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1522053638187},{"path":"D:\\SVNProjects\\thingbluangular5svnv1\\thingblusvn\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1519266497000}],"contextDependencies":[],"result":["/**\r\n* @license\r\n* Copyright Google Inc. All Rights Reserved.\r\n*\r\n* Use of this source code is governed by an MIT-style license that can be\r\n* found in the LICENSE file at https://angular.io/license\r\n*/\r\n(function (global, factory) {\r\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory() :\r\n        typeof define === 'function' && define.amd ? define(factory) :\r\n            (factory());\r\n}(this, (function () {\r\n    'use strict';\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * @fileoverview\r\n     * @suppress {globalThis}\r\n     */\r\n    var NEWLINE = '\\n';\r\n    var IGNORE_FRAMES = {};\r\n    var creationTrace = '__creationTrace__';\r\n    var ERROR_TAG = 'STACKTRACE TRACKING';\r\n    var SEP_TAG = '__SEP_TAG__';\r\n    var sepTemplate = SEP_TAG + '@[native]';\r\n    var LongStackTrace = /*@__PURE__*/ (function () {\r\n        function LongStackTrace() {\r\n            this.error = getStacktrace();\r\n            this.timestamp = new Date();\r\n        }\r\n        return LongStackTrace;\r\n    }());\r\n    function getStacktraceWithUncaughtError() {\r\n        return new Error(ERROR_TAG);\r\n    }\r\n    function getStacktraceWithCaughtError() {\r\n        try {\r\n            throw getStacktraceWithUncaughtError();\r\n        }\r\n        catch (err) {\r\n            return err;\r\n        }\r\n    }\r\n    // Some implementations of exception handling don't create a stack trace if the exception\r\n    // isn't thrown, however it's faster not to actually throw the exception.\r\n    var error = getStacktraceWithUncaughtError();\r\n    var caughtError = getStacktraceWithCaughtError();\r\n    var getStacktrace = error.stack ?\r\n        getStacktraceWithUncaughtError :\r\n        (caughtError.stack ? getStacktraceWithCaughtError : getStacktraceWithUncaughtError);\r\n    function getFrames(error) {\r\n        return error.stack ? error.stack.split(NEWLINE) : [];\r\n    }\r\n    function addErrorStack(lines, error) {\r\n        var trace = getFrames(error);\r\n        for (var i = 0; i < trace.length; i++) {\r\n            var frame = trace[i];\r\n            // Filter out the Frames which are part of stack capturing.\r\n            if (!IGNORE_FRAMES.hasOwnProperty(frame)) {\r\n                lines.push(trace[i]);\r\n            }\r\n        }\r\n    }\r\n    function renderLongStackTrace(frames, stack) {\r\n        var longTrace = [stack ? stack.trim() : ''];\r\n        if (frames) {\r\n            var timestamp = new Date().getTime();\r\n            for (var i = 0; i < frames.length; i++) {\r\n                var traceFrames = frames[i];\r\n                var lastTime = traceFrames.timestamp;\r\n                var separator = \"____________________Elapsed \" + (timestamp - lastTime.getTime()) + \" ms; At: \" + lastTime;\r\n                separator = separator.replace(/[^\\w\\d]/g, '_');\r\n                longTrace.push(sepTemplate.replace(SEP_TAG, separator));\r\n                addErrorStack(longTrace, traceFrames.error);\r\n                timestamp = lastTime.getTime();\r\n            }\r\n        }\r\n        return longTrace.join(NEWLINE);\r\n    }\r\n    Zone['longStackTraceZoneSpec'] = {\r\n        name: 'long-stack-trace',\r\n        longStackTraceLimit: 10,\r\n        // add a getLongStackTrace method in spec to\r\n        // handle handled reject promise error.\r\n        getLongStackTrace: function (error) {\r\n            if (!error) {\r\n                return undefined;\r\n            }\r\n            var trace = error[Zone.__symbol__('currentTaskTrace')];\r\n            if (!trace) {\r\n                return error.stack;\r\n            }\r\n            return renderLongStackTrace(trace, error.stack);\r\n        },\r\n        onScheduleTask: function (parentZoneDelegate, currentZone, targetZone, task) {\r\n            if (Error.stackTraceLimit > 0) {\r\n                // if Error.stackTraceLimit is 0, means stack trace\r\n                // is disabled, so we don't need to generate long stack trace\r\n                // this will improve performance in some test(some test will\r\n                // set stackTraceLimit to 0, https://github.com/angular/zone.js/issues/698\r\n                var currentTask = Zone.currentTask;\r\n                var trace = currentTask && currentTask.data && currentTask.data[creationTrace] || [];\r\n                trace = [new LongStackTrace()].concat(trace);\r\n                if (trace.length > this.longStackTraceLimit) {\r\n                    trace.length = this.longStackTraceLimit;\r\n                }\r\n                if (!task.data)\r\n                    task.data = {};\r\n                task.data[creationTrace] = trace;\r\n            }\r\n            return parentZoneDelegate.scheduleTask(targetZone, task);\r\n        },\r\n        onHandleError: function (parentZoneDelegate, currentZone, targetZone, error) {\r\n            if (Error.stackTraceLimit > 0) {\r\n                // if Error.stackTraceLimit is 0, means stack trace\r\n                // is disabled, so we don't need to generate long stack trace\r\n                // this will improve performance in some test(some test will\r\n                // set stackTraceLimit to 0, https://github.com/angular/zone.js/issues/698\r\n                var parentTask = Zone.currentTask || error.task;\r\n                if (error instanceof Error && parentTask) {\r\n                    var longStack = renderLongStackTrace(parentTask.data && parentTask.data[creationTrace], error.stack);\r\n                    try {\r\n                        error.stack = error.longStack = longStack;\r\n                    }\r\n                    catch (err) {\r\n                    }\r\n                }\r\n            }\r\n            return parentZoneDelegate.handleError(targetZone, error);\r\n        }\r\n    };\r\n    function captureStackTraces(stackTraces, count) {\r\n        if (count > 0) {\r\n            stackTraces.push(getFrames((new LongStackTrace()).error));\r\n            captureStackTraces(stackTraces, count - 1);\r\n        }\r\n    }\r\n    function computeIgnoreFrames() {\r\n        if (Error.stackTraceLimit <= 0) {\r\n            return;\r\n        }\r\n        var frames = [];\r\n        captureStackTraces(frames, 2);\r\n        var frames1 = frames[0];\r\n        var frames2 = frames[1];\r\n        for (var i = 0; i < frames1.length; i++) {\r\n            var frame1 = frames1[i];\r\n            if (frame1.indexOf(ERROR_TAG) == -1) {\r\n                var match = frame1.match(/^\\s*at\\s+/);\r\n                if (match) {\r\n                    sepTemplate = match[0] + SEP_TAG + ' (http://localhost)';\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        for (var i = 0; i < frames1.length; i++) {\r\n            var frame1 = frames1[i];\r\n            var frame2 = frames2[i];\r\n            if (frame1 === frame2) {\r\n                IGNORE_FRAMES[frame1] = true;\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    computeIgnoreFrames();\r\n})));\r\n",null]}